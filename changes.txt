diff --git a/.gitignore b/.gitignore
index f493fa9..f835446 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,4 +13,5 @@ lcov.info
 /broadcast/*/31337/
 /broadcast/**/dry-run/
 
-.DS_Store
\ No newline at end of file
+.DS_Store
+node_modules
diff --git a/contracts/LoanManager.sol b/contracts/LoanManager.sol
index 99b00d3..1f446a4 100644
--- a/contracts/LoanManager.sol
+++ b/contracts/LoanManager.sol
@@ -21,7 +21,6 @@ import {
  * @notice This contract is intended to be used by NSTBL hub and future nealthy products
  * @dev This contract allows NSTBL hub to deposit assets into Maple Protocol pools, request and redeem Maple Protocol tokens, and perform various other loan management operations
  */
-
 contract LoanManager is ILoanManager, LoanManagerStorage, VersionedInitializable {
     using SafeERC20 for IERC20Helper;
     using Address for address;
@@ -314,16 +313,16 @@ contract LoanManager is ILoanManager, LoanManagerStorage, VersionedInitializable
         version_ = getRevision();
     }
 
-    /**
-     * @dev Get the total time period for redemption
-     * @return windowStart_ The starting time of the window
-     * @return windowEnd_ The ending time of the window
-     */
-    function getRedemptionWindow() external view returns (uint256 windowStart_, uint256 windowEnd_) {
-        require(awaitingRedemption, "LM: No redemption requested");
-        uint256 exitCycleId = IWithdrawalManagerStorage(MAPLE_WITHDRAWAL_MANAGER_USDC).exitCycleId(address(this));
-        (windowStart_, windowEnd_) = IWithdrawalManager(MAPLE_WITHDRAWAL_MANAGER_USDC).getWindowAtId(exitCycleId);
-    }
+    // /**
+    //  * @dev Get the total time period for redemption
+    //  * @return windowStart_ The starting time of the window
+    //  * @return windowEnd_ The ending time of the window
+    //  */
+    // function getRedemptionWindow() external view returns (uint256 windowStart_, uint256 windowEnd_) {
+    //     require(awaitingRedemption, "LM: No redemption requested");
+    //     uint256 exitCycleId = IWithdrawalManagerStorage(MAPLE_WITHDRAWAL_MANAGER_USDC).exitCycleId(address(this));
+    //     (windowStart_, windowEnd_) = IWithdrawalManager(MAPLE_WITHDRAWAL_MANAGER_USDC).getWindowAtId(exitCycleId);
+    // }
 
     /*//////////////////////////////////////////////////////////////
     Externals - setters
@@ -393,12 +392,9 @@ contract LoanManager is ILoanManager, LoanManagerStorage, VersionedInitializable
         internal
         returns (uint256)
     {
-        uint256 exitCycleId = IWithdrawalManagerStorage(withdrawManager_).exitCycleId(address(this));
-        (uint256 windowStart, uint256 windowEnd) = IWithdrawalManager(withdrawManager_).getWindowAtId(exitCycleId);
+        require(IWithdrawalManagerStorage(withdrawManager_).lockedShares(address(this)) > 0, "LM: No shares to redeem");
         uint256 _shares = escrowedMapleShares;
 
-        require(block.timestamp >= windowStart && block.timestamp < windowEnd, "LM: Not in Window");
-
         uint256 stablesRedeemed = IPool(pool_).redeem(_shares, nstblHub, address(this));
         assetsRedeemed += stablesRedeemed;
         escrowedMapleShares = IWithdrawalManagerStorage(withdrawManager_).lockedShares(address(this));
@@ -419,12 +415,8 @@ contract LoanManager is ILoanManager, LoanManagerStorage, VersionedInitializable
      * @notice This function transfers locked Maple Shares from Maple Protocol to loanManager, updates relevant accounting data, and emits a `Remove` event
      */
     function _removeMapleCash(address asset_, address pool_, address withdrawManager_) internal {
-        uint256 exitCycleId = IWithdrawalManagerStorage(withdrawManager_).exitCycleId(address(this));
-        (, uint256 windowEnd) = IWithdrawalManager(withdrawManager_).getWindowAtId(exitCycleId);
+        require(IWithdrawalManagerStorage(withdrawManager_).requestIds(address(this)) > 0, "LM: Not in Queue");
         uint256 _shares = escrowedMapleShares;
-
-        require(block.timestamp > windowEnd, "LM: Redemption Pending");
-
         uint256 sharesRemoved = IPool(pool_).removeShares(_shares, address(this));
         escrowedMapleShares -= sharesRemoved;
 
diff --git a/contracts/LoanManagerStorage.sol b/contracts/LoanManagerStorage.sol
index f9f2168..57ae423 100644
--- a/contracts/LoanManagerStorage.sol
+++ b/contracts/LoanManagerStorage.sol
@@ -17,7 +17,7 @@ contract LoanManagerStorage {
     address public immutable MAPLE_POOL_MANAGER_USDC = 0x219654A61a0BC394055652986BE403fa14405Bb8;
 
     /// @notice addresses of the maple withdrawal managers for USDC cash pools
-    address public immutable MAPLE_WITHDRAWAL_MANAGER_USDC = 0x1146691782c089bCF0B19aCb8620943a35eebD12;
+    address public immutable MAPLE_WITHDRAWAL_MANAGER_USDC = 0x447dcEa1d616f792645ed6E71bC32955A0dBcbAa;
 
     /*//////////////////////////////////////////////////////////////
     Storage
diff --git a/contracts/interfaces/maple/IWithdrawalManager.sol b/contracts/interfaces/maple/IWithdrawalManager.sol
index 6906150..18caf03 100644
--- a/contracts/interfaces/maple/IWithdrawalManager.sol
+++ b/contracts/interfaces/maple/IWithdrawalManager.sol
@@ -1,7 +1,5 @@
 // SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.21;
-
-// import { IMapleProxied } from "../../modules/maple-proxy-factory/contracts/interfaces/IMapleProxied.sol";
+pragma solidity ^0.8.7;
 
 import { IWithdrawalManagerStorage } from "./IWithdrawalManagerStorage.sol";
 
@@ -10,150 +8,194 @@ interface IWithdrawalManager is IWithdrawalManagerStorage {
      *
      */
     /**
-     * State Changing Functions                                                                                                       **
+     * Events                                                                                                                         **
      */
     /**
      *
      */
 
     /**
-     *  @dev   Add shares to the withdrawal manager.
-     *  @param shares_ Amount of shares to add.
-     *  @param owner_  Address of the owner of shares.
+     *  @dev   Emitted when a manual redemption takes place.
+     *  @param owner           Address of the account.
+     *  @param sharesDecreased Amount of shares redeemed.
      */
-    function addShares(uint256 shares_, address owner_) external;
+    event ManualSharesDecreased(address indexed owner, uint256 sharesDecreased);
 
     /**
-     *  @dev   Process the exit of an account.
-     *  @param requestedShares_ Amount of initially requested shares.
-     *  @param owner_           Address of the account which will be processed for exit.
+     *  @dev   Emitted when a manual redemption is processed.
+     *  @param owner       Address of the account.
+     *  @param sharesAdded Amount of shares added to the redeemable amount.
      */
-    function processExit(uint256 requestedShares_, address owner_)
-        external
-        returns (uint256 redeemableShares_, uint256 resultingAssets_);
+    event ManualSharesIncreased(address indexed owner, uint256 sharesAdded);
+
+    /**
+     *  @dev   Emitted when the withdrawal type of an account is updated.
+     *  @param owner     Address of the account.
+     *  @param isManual `true` if the withdrawal is manual, `false` if it is automatic.
+     */
+    event ManualWithdrawalSet(address indexed owner, bool isManual);
+
+    /**
+     *  @dev   Emitted when a withdrawal request is created.
+     *  @param requestId Identifier of the withdrawal request.
+     *  @param owner     Address of the owner of the shares.
+     *  @param shares    Amount of shares requested for redemption.
+     */
+    event RequestCreated(uint128 indexed requestId, address indexed owner, uint256 shares);
 
     /**
-     *  @dev   Remove shares to the withdrawal manager.
-     *  @param shares_ Amount of shares to remove.
-     *  @param owner_  Address of the owner of shares.
+     *  @dev   Emitted when a withdrawal request is updated.
+     *  @param requestId Identifier of the withdrawal request.
+     *  @param shares    Amount of shares reduced during a redemption request.
      */
-    function removeShares(uint256 shares_, address owner_) external returns (uint256 sharesReturned_);
+    event RequestDecreased(uint128 indexed requestId, uint256 shares);
 
     /**
-     *  @dev   Sets up a new exit configuration.
-     *  @param cycleDuration_  The total duration, in seconds, of a withdrawal cycle.
-     *  @param windowDuration_ The duration, in seconds, of the withdrawal window.
+     *  @dev   Emitted when a withdrawal request is processed.
+     *  @param requestId Identifier of the withdrawal request.
+     *  @param owner     The owner of the shares.
+     *  @param shares    Amount of redeemable shares.
+     *  @param assets    Amount of withdrawable assets.
      */
-    function setExitConfig(uint256 cycleDuration_, uint256 windowDuration_) external;
+    event RequestProcessed(uint128 indexed requestId, address indexed owner, uint256 shares, uint256 assets);
+
+    /**
+     *  @dev   Emitted when a withdrawal request is removed.
+     *  @param requestId Identifier of the withdrawal request.
+     */
+    event RequestRemoved(uint128 indexed requestId);
 
     /**
      *
      */
     /**
-     * View Functions                                                                                                                 **
+     * State-Changing Functions                                                                                                       **
      */
     /**
      *
      */
 
     /**
-     *  @dev    Gets the asset address used in this withdrawal manager.
-     *  @return asset_ Address of the asset.
+     *  @dev   Add shares to the withdrawal manager.
+     *  @param shares Amount of shares to add.
+     *  @param owner  Address of the owner of shares.
      */
-    function asset() external view returns (address asset_);
+    function addShares(uint256 shares, address owner) external;
 
     /**
-     *  @dev    Gets the configuration of a given cycle id.
-     *  @param  cycleId_  The id of the cycle.
-     *  @return config_ The configuration info corresponding to the cycle.
+     *  @dev    Processes a withdrawal request.
+     *          Uses the current exchange rate to calculate the amount of assets withdrawn.
+     *  @param  shares           Amount of shares that should be redeemed.
+     *  @param  owner            Address of the account to process.
+     *  @return redeemableShares Amount of shares that will be burned.
+     *  @return resultingAssets  Amount of assets that will be withdrawn.
      */
-    function getConfigAtId(uint256 cycleId_) external view returns (CycleConfig memory config_);
+    function processExit(uint256 shares, address owner)
+        external
+        returns (uint256 redeemableShares, uint256 resultingAssets);
 
     /**
-     *  @dev    Gets the configuration of the current cycle id.
-     *  @return config_ The configuration info corresponding to the cycle.
+     *  @dev   Processes pending redemption requests.
+     *         Requests are processed in the order they were submitted.
+     *         Automatic withdrawal requests will be fulfilled atomically.
+     *  @param maxSharesToProcess Maximum number of shares that will be processed during the call.
      */
-    function getCurrentConfig() external view returns (CycleConfig memory config_);
+    function processRedemptions(uint256 maxSharesToProcess) external;
 
     /**
-     *  @dev   Gets the id of the current cycle.
-     *  @param cycleId_ The id of the current cycle.
+     *  @dev    Removes shares from the withdrawal manager.
+     *  @param  shares         Amount of shares to remove.
+     *  @param  owner          Address of the owner of shares.
+     *  @return sharesReturned Amount of shares that were returned.
      */
-    function getCurrentCycleId() external view returns (uint256 cycleId_);
+    function removeShares(uint256 shares, address owner) external returns (uint256 sharesReturned);
 
     /**
-     *  @dev    Gets the shares and assets that are redeemable for a given user.
-     *  @param  lockedShares_     The amount of shares that are locked.
-     *  @param  owner_            The owner of the shares.
-     *  @return redeemableShares_ The amount of shares that are redeemable based on current liquidity.
-     *  @return resultingAssets_  The corresponding amount of assets that can be redeemed using the shares.
-     *  @return partialLiquidity_ Boolean indicating if there is enough liquidity to facilitate a full redemption.
+     *  @dev   Removes a withdrawal request from the queue.
+     *         Can only be called by the pool delegate.
+     *  @param owner Address of the owner of shares.
      */
-    function getRedeemableAmounts(uint256 lockedShares_, address owner_)
-        external
-        view
-        returns (uint256 redeemableShares_, uint256 resultingAssets_, bool partialLiquidity_);
+    function removeRequest(address owner) external;
+
+    /**
+     *  @dev   Defines if an account will withdraw shares manually or automatically.
+     *  @param account  Address of the account.
+     *  @param isManual `true` if the account withdraws manually, `false` if the withdrawals are performed automatically.
+     */
+    function setManualWithdrawal(address account, bool isManual) external;
 
     /**
-     *  @dev    Gets the timestamp of the beginning of the withdrawal window for a given cycle.
-     *  @param  cycleId_     The id of the current cycle.
-     *  @return windowStart_ The timestamp of the beginning of the cycle, which is the same as the beginning of the withdrawal window.
+     *
+     */
+    /**
+     * View Functions                                                                                                                 **
+     */
+    /**
+     *
      */
-    function getWindowStart(uint256 cycleId_) external view returns (uint256 windowStart_);
 
     /**
-     *  @dev    Gets the timestamps of the beginning and end of the withdrawal window for a given cycle.
-     *  @param  cycleId_     The id of the current cycle.
-     *  @return windowStart_ The timestamp of the beginning of the cycle, which is the same as the beginning of the withdrawal window.
-     *  @return windowEnd_   The timestamp of the end of the withdrawal window.
+     *  @dev   Returns the address of the underlying pool asset.
+     *  @param asset Address of the underlying pool asset.
      */
-    function getWindowAtId(uint256 cycleId_) external view returns (uint256 windowStart_, uint256 windowEnd_);
+    function asset() external view returns (address asset);
 
     /**
-     *  @dev    Gets the address of globals.
-     *  @return globals_ The address of globals.
+     *  @dev   Returns the address of the globals contract.
+     *  @param globals Address of the globals contract.
      */
-    function globals() external view returns (address globals_);
+    function globals() external view returns (address globals);
 
     /**
-     *  @dev    Gets the address of the governor.
-     *  @return governor_ The address of the governor.
+     *  @dev   Return the address of the governor.
+     *  @param governor Address of the governor contract.
      */
-    function governor() external view returns (address governor_);
+    function governor() external view returns (address governor);
 
     /**
-     *  @dev    Checks if an account is included in an exit window.
-     *  @param  owner_          The address of the share owners to check.
-     *  @return isInExitWindow_ A boolean indicating whether or not the account is in an exit window.
+     *  @dev    Returns if a user is able to withdraw. Required for compatibility with pool managers.
+     *          NOTE: Always returns true to fulfil interface requirements.
+     *  @param  owner_          The account to check if it's in withdraw window.
+     *  @return isInExitWindow_ True if the account is in the withdraw window.
      */
     function isInExitWindow(address owner_) external view returns (bool isInExitWindow_);
 
     /**
      *  @dev    Gets the total amount of funds that need to be locked to fulfill exits.
+     *          NOTE: Always zero for this implementation.
      *  @return lockedLiquidity_ The amount of locked liquidity.
      */
     function lockedLiquidity() external view returns (uint256 lockedLiquidity_);
 
     /**
-     *  @dev    Gets the pool delegate address.
-     *  @return poolDelegate_ Address of the pool delegate.
+     *  @dev    Gets the amount of locked shares for an account.
+     *  @param  owner_        The address to check the exit for.
+     *  @return lockedShares_ The amount of manual shares available.
      */
-    function poolDelegate() external view returns (address poolDelegate_);
+    function lockedShares(address owner_) external view returns (uint256 lockedShares_);
 
     /**
-     *  @dev    Gets the amount of shares that can be redeemed.
-     *  @param  owner_            The address to check the redemption for.
-     *  @param  shares_           The amount of requested shares to redeem.
-     *  @return redeemableShares_ The amount of shares that can be redeemed.
-     *  @return resultingAssets_  The amount of assets that will be returned for `redeemableShares`.
+     *  @dev   Returns the address of the pool delegate.
+     *  @param poolDelegate Address of the pool delegate.
      */
-    function previewRedeem(address owner_, uint256 shares_)
+    function poolDelegate() external view returns (address poolDelegate);
+
+    /**
+     *  @dev    Returns the amount of shares that can be redeemed.
+     *          NOTE: The `shares` value is ignored.
+     *  @param  owner            Address of the share owner
+     *  @param  shares           Amount of shares to redeem.
+     *  @return redeemableShares Amount of shares that can be redeemed.
+     *  @return resultingAssets  Amount of assets that can be withdrawn.
+     */
+    function previewRedeem(address owner, uint256 shares)
         external
         view
-        returns (uint256 redeemableShares_, uint256 resultingAssets_);
+        returns (uint256 redeemableShares, uint256 resultingAssets);
 
     /**
      *  @dev    Gets the amount of shares that can be withdrawn.
+     *          NOTE: Values just passed through as withdraw is not implemented.
      *  @param  owner_            The address to check the withdrawal for.
      *  @param  assets_           The amount of requested shares to withdraw.
      *  @return redeemableAssets_ The amount of assets that can be withdrawn.
@@ -163,4 +205,18 @@ interface IWithdrawalManager is IWithdrawalManagerStorage {
         external
         view
         returns (uint256 redeemableAssets_, uint256 resultingShares_);
+
+    /**
+     *  @dev    Returns the owner and amount of shares associated with a withdrawal request.
+     *  @param  requestId Identifier of the withdrawal request.
+     *  @return owner     Address of the share owner.
+     *  @return shares    Amount of shares pending redemption.
+     */
+    function requests(uint128 requestId) external view returns (address owner, uint256 shares);
+
+    /**
+     *  @dev   Returns the address of the security admin.
+     *  @param securityAdmin Address of the security admin.
+     */
+    function securityAdmin() external view returns (address securityAdmin);
 }
diff --git a/contracts/interfaces/maple/IWithdrawalManagerStorage.sol b/contracts/interfaces/maple/IWithdrawalManagerStorage.sol
index 52e20a9..0faf9cd 100644
--- a/contracts/interfaces/maple/IWithdrawalManagerStorage.sol
+++ b/contracts/interfaces/maple/IWithdrawalManagerStorage.sol
@@ -1,62 +1,53 @@
 // SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.21;
+pragma solidity ^0.8.7;
 
 interface IWithdrawalManagerStorage {
-    struct CycleConfig {
-        uint64 initialCycleId; // Identifier of the first withdrawal cycle using this configuration.
-        uint64 initialCycleTime; // Timestamp of the first withdrawal cycle using this configuration.
-        uint64 cycleDuration; // Duration of the withdrawal cycle.
-        uint64 windowDuration; // Duration of the withdrawal window.
-    }
-
     /**
-     *  @dev    Gets the configuration for a given config id.
-     *  @param  configId_        The id of the configuration to use.
-     *  @return initialCycleId   Identifier of the first withdrawal cycle using this configuration.
-     *  @return initialCycleTime Timestamp of the first withdrawal cycle using this configuration.
-     *  @return cycleDuration    Duration of the withdrawal cycle.
-     *  @return windowDuration   Duration of the withdrawal window.
+     *  @dev    Returns the address of the pool contract.
+     *  @return pool Address of the pool contract.
      */
-    function cycleConfigs(uint256 configId_)
-        external
-        returns (uint64 initialCycleId, uint64 initialCycleTime, uint64 cycleDuration, uint64 windowDuration);
+    function pool() external view returns (address pool);
 
     /**
-     *  @dev    Gets the id of the cycle that account can exit on.
-     *  @param  account_ The address to check the exit for.
-     *  @return cycleId_ The id of the cycle that account can exit on.
+     *  @dev    Returns the address of the pool manager contract.
+     *  @return poolManager Address of the pool manager contract.
      */
-    function exitCycleId(address account_) external view returns (uint256 cycleId_);
+    function poolManager() external view returns (address poolManager);
 
     /**
-     *  @dev    Gets the most recent configuration id.
-     *  @return configId_ The id of the most recent configuration.
+     *  @dev    Returns the total amount of shares pending redemption.
+     *  @return totalShares Total amount of shares pending redemption.
      */
-    function latestConfigId() external view returns (uint256 configId_);
+    function totalShares() external view returns (uint256 totalShares);
 
     /**
-     *  @dev    Gets the amount of locked shares for an account.
-     *  @param  account_      The address to check the exit for.
-     *  @return lockedShares_ The amount of shares locked.
+     *  @dev    Checks if an account is set to perform withdrawals manually.
+     *  @param  account  Address of the account.
+     *  @return isManual `true` if the account withdraws manually, `false` if not.
      */
-    function lockedShares(address account_) external view returns (uint256 lockedShares_);
+    function isManualWithdrawal(address account) external view returns (bool isManual);
 
     /**
-     *  @dev    Gets the address of the pool associated with this withdrawal manager.
-     *  @return pool_ The address of the pool.
+     *  @dev    Returns the amount of shares available for manual withdrawal.
+     *  @param  owner           The address of the owner of shares.
+     *  @return sharesAvailable Amount of shares available for manual withdrawal.
      */
-    function pool() external view returns (address pool_);
+    function manualSharesAvailable(address owner) external view returns (uint256 sharesAvailable);
 
     /**
-     *  @dev    Gets the address of the pool manager associated with this withdrawal manager.
-     *  @return poolManager_ The address of the pool manager.
+     *  @dev    Returns the request identifier of an account.
+     *          Returns zero if the account does not have a withdrawal request.
+     *  @param  account   Address of the account.
+     *  @return requestId Identifier of the withdrawal request.
      */
-    function poolManager() external view returns (address poolManager_);
+    function requestIds(address account) external view returns (uint128 requestId);
 
     /**
-     *  @dev    Gets the amount of shares for a cycle.
-     *  @param  cycleId_          The id to cycle to check.
-     *  @return totalCycleShares_ The amount of shares in the cycle.
+     *  @dev    Returns the first and last withdrawal requests pending redemption.
+     *  @return nextRequestId Identifier of the next withdrawal request that will be processed.
+     *  @return lastRequestId Identifier of the last created withdrawal request.
      */
-    function totalCycleShares(uint256 cycleId_) external view returns (uint256 totalCycleShares_);
+    function queue() external view returns (uint128 nextRequestId, uint128 lastRequestId);
+
+    function lockedShares(address user) external returns (uint256 lockedShares);
 }
diff --git a/contracts/upgradeable/test/LoanManagerV2.sol b/contracts/upgradeable/test/LoanManagerV2.sol
index 9ae897a..4b0a345 100644
--- a/contracts/upgradeable/test/LoanManagerV2.sol
+++ b/contracts/upgradeable/test/LoanManagerV2.sol
@@ -1,364 +1,364 @@
-// SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.21;
-
-import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
-import "@openzeppelin/contracts/utils/Address.sol";
-import { VersionedInitializable } from "../VersionedInitializable.sol";
-import {
-    IPool,
-    IERC20Helper,
-    IWithdrawalManagerStorage,
-    IWithdrawalManager,
-    IACLManager,
-    TokenLP,
-    LoanManagerStorageV2
-} from "./LoanManagerStorageV2.sol";
-
-// This contract is just to test upgrade functionality and will not be used in production
-contract LoanManagerV2 is LoanManagerStorageV2, VersionedInitializable {
-    using SafeERC20 for IERC20Helper;
-    using Address for address;
-
-    uint256 internal constant REVISION = 222;
-    uint256 private _locked;
-
-    /*//////////////////////////////////////////////////////////////
-    MODIFIERS
-    //////////////////////////////////////////////////////////////*/
-
-    /**
-     * @dev Modifier to ensure that only authorized callers can execute a function.
-     */
-    modifier authorizedCaller() {
-        require(IACLManager(aclManager).authorizedCallersLoanManager(msg.sender), "Loan Manager: unAuth Hub");
-        _;
-    }
-
-    /**
-     * @dev Modifier to ensure that only the admin can execute a function.
-     */
-    modifier onlyAdmin() {
-        require(msg.sender == IACLManager(aclManager).admin(), "LM: unAuth Admin");
-        _;
-    }
-
-    /**
-     * @dev Modifier to validate input parameters.
-     */
-    modifier validInput(uint256 _amount) {
-        require(_amount > 0, "LM: Insufficient amount");
-        _;
-    }
-
-    /**
-     * @dev Modifier to prevent reentrancy attacks.
-     */
-    modifier nonReentrant() {
-        require(_locked == 1, "LM:LOCKED");
-
-        _locked = 2;
-
-        _;
-
-        _locked = 1;
-    }
-
-    /*//////////////////////////////////////////////////////////////
-    CONSTRUCTOR
-    //////////////////////////////////////////////////////////////*/
-
-    /**
-     * @dev Constructor to set immutables the LoanManager contract.
-     */
-    constructor() {
-        usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
-    }
-
-    function initialize(uint256 _newVar) external initializer {
-        newVar = _newVar;
-    }
-
-    /*//////////////////////////////////////////////////////////////
-    LP FUNCTIONS
-    //////////////////////////////////////////////////////////////*/
-
-    /**
-     * @dev Deposit assets into the Maple Protocol pool and mint LP tokens (lUSDC) to the NSTBL Hub.
-     * @notice The LP tokens corresponding to the shares issued by the Maple Protocol pool are minted.
-     * @param _amount The amount of the asset to deposit.
-     */
-    function deposit(uint256 _amount) external authorizedCaller nonReentrant {
-        _depositMapleCash(_amount, usdc, mapleUSDCPool, address(lUSDC), MAPLE_POOL_MANAGER_USDC);
-    }
-
-    /**
-     * @dev Request the redemption of LP tokens issued. (lUSDC)
-     * @notice The shares corresponding to the LP tokens are requested for redemption from the Maple Protocol pool.
-     * @param _lpTokens The amount of LP tokens to redeem.
-     */
-    function requestRedeem(uint256 _lpTokens) external authorizedCaller nonReentrant validInput(_lpTokens) {
-        _requestRedeemMapleCash(_lpTokens, usdc, mapleUSDCPool);
-    }
-
-    /**
-     * @dev Redeem LP tokens issued. (lUSDC)
-     * @notice The shares corresponding to the LP tokens that were requested for redemption are redeemed from the Maple Protocol pool.
-     * @notice The shares are burned in the Maple Protocol pool contract and the LP tokens are burned here.
-     */
-    function redeem() external authorizedCaller nonReentrant {
-        require(awaitingRedemption, "LM: No redemption requested");
-        _redeemMapleCash(usdc, mapleUSDCPool, address(lUSDC), MAPLE_WITHDRAWAL_MANAGER_USDC);
-    }
-
-    /**
-     * @dev Remove Locked Maple Shares (during request redemption).
-     * @notice The shares corresponding to the LP tokens that were requested for redemption are removed from the Maple Protocol pool.
-     * @notice The shares are transferred Maple Protocol's withdrawal manager contract back to Nealthy's loan Manager.
-     */
-    function remove() external authorizedCaller nonReentrant {
-        require(awaitingRedemption, "LM: No Tokens to remove");
-        _removeMapleCash(usdc, mapleUSDCPool, MAPLE_WITHDRAWAL_MANAGER_USDC);
-    }
-
-    /*//////////////////////////////////////////////////////////////
-    INTERNALS
-    //////////////////////////////////////////////////////////////*/
-
-    /**
-     * @dev Internal function to deposit assets into the Maple Protocol pool and mint LP tokens.
-     * @param _amount The amount of the asset to deposit.
-     * @param _asset The address of the asset being deposited.
-     * @param _pool The address of the Maple Protocol pool.
-     * @param _lpToken The address of the LP token associated with the pool.
-     * @param _poolManager The address of the Maple Protocol pool manager contract.
-     * @notice This function checks if the deposit amount is valid, transfers the assets from the sender to this contract, approves the pool to spend the assets, updates relevant accounting data, and emits a `Deposit` event.
-     */
-    function _depositMapleCash(uint256 _amount, address _asset, address _pool, address _lpToken, address _poolManager)
-        internal
-    {
-        require(isValidDepositAmount(_amount, _pool, _poolManager), "LM: Invalid amount");
-        uint256 lpTokens;
-        uint256 sharesReceived;
-        IERC20Helper(_asset).safeTransferFrom(msg.sender, address(this), _amount);
-        IERC20Helper(_asset).safeIncreaseAllowance(_pool, _amount);
-
-        totalAssetsReceived += _amount;
-        uint256 balBefore = IPool(_pool).balanceOf(address(this));
-        IPool(_pool).deposit(_amount, address(this));
-        sharesReceived = IPool(_pool).balanceOf(address(this)) - balBefore;
-        totalSharesReceived += sharesReceived;
-        lpTokens = sharesReceived * 10 ** adjustedDecimals;
-        totalLPTokensMinted += lpTokens;
-        IERC20Helper(_lpToken).mint(nstblHub, lpTokens);
-        emit Deposit(_asset, _amount, lpTokens, sharesReceived);
-    }
-
-    /**
-     * @dev Internal function to request the redemption of LP tokens issued. (lUSDC)
-     * @param _lpTokens The amount of LP tokens to redeem.
-     * @param _asset The address of the asset to redeem.
-     * @param _pool The address of the Maple Protocol pool.
-     * @notice This function checks if redemption is pending and if there are sufficient shares to redeem, records the escrowed shares, and emits a `RequestRedeem` event.
-     */
-    function _requestRedeemMapleCash(uint256 _lpTokens, address _asset, address _pool) internal {
-        require(!awaitingRedemption, "LM: Redemption Pending");
-        require(IPool(_pool).balanceOf(address(this)) >= _lpTokens / 10 ** adjustedDecimals, "LM: Insufficient Shares");
-        escrowedMapleShares = IPool(_pool).requestRedeem(_lpTokens / 10 ** adjustedDecimals, address(this));
-        awaitingRedemption = true;
-        emit RequestRedeem(_asset, _lpTokens, escrowedMapleShares);
-    }
-
-    /**
-     * @dev Internal function to Redeem LP tokens issued. (lUSDC)
-     * @param _asset The address of the asset to redeem.
-     * @param _pool The address of the Maple Protocol pool.
-     * @param _lpToken The address of the LP token associated with the pool.
-     * @param _withdrawManager The address of the withdrawal manager contract.
-     * @notice This function redeems Maple Protocol tokens, burns the associated LP tokens, updates relevant accounting data, and emits a `Redeem` event.
-     */
-    function _redeemMapleCash(address _asset, address _pool, address _lpToken, address _withdrawManager) internal {
-        uint256 exitCycleId = IWithdrawalManagerStorage(_withdrawManager).exitCycleId(address(this));
-        (uint256 windowStart, uint256 windowEnd) = IWithdrawalManager(_withdrawManager).getWindowAtId(exitCycleId);
-        uint256 _shares = escrowedMapleShares;
-
-        require(block.timestamp >= windowStart && block.timestamp < windowEnd, "LM: Not in Window");
-
-        uint256 stablesRedeemed = IPool(_pool).redeem(_shares, nstblHub, address(this));
-        assetsRedeemed += stablesRedeemed;
-        escrowedMapleShares = IWithdrawalManagerStorage(_withdrawManager).lockedShares(address(this));
-        totalLPTokensBurned += (_shares - escrowedMapleShares) * 10 ** adjustedDecimals;
-        IERC20Helper(_lpToken).burn(nstblHub, (_shares - escrowedMapleShares) * 10 ** adjustedDecimals);
-        if (escrowedMapleShares == 0) {
-            awaitingRedemption = false;
-        }
-        emit Redeem(_asset, _shares, assetsRedeemed);
-    }
-
-    /**
-     * @dev Internal function to remove locked Maple Shares.
-     * @param _asset The address of the asset to redeem.
-     * @param _pool The address of the Maple Protocol pool.
-     * @param _withdrawManager The address of the withdrawal manager contract.
-     * @notice This function transfers locked Maple Shares from Maple Protocol to loanManager, updates relevant accounting data, and emits a `Remove` event.
-     */
-    function _removeMapleCash(address _asset, address _pool, address _withdrawManager) internal {
-        uint256 exitCycleId = IWithdrawalManagerStorage(_withdrawManager).exitCycleId(address(this));
-        (, uint256 windowEnd) = IWithdrawalManager(_withdrawManager).getWindowAtId(exitCycleId);
-        uint256 _shares = escrowedMapleShares;
-
-        require(block.timestamp > windowEnd, "LM: Redemption Pending");
-
-        uint256 sharesRemoved = IPool(_pool).removeShares(_shares, address(this));
-        escrowedMapleShares -= sharesRemoved;
-
-        if (escrowedMapleShares == 0) {
-            awaitingRedemption = false;
-        }
-
-        emit Removed(_asset, _shares);
-    }
-
-    /*//////////////////////////////////////////////////////////////
-    VIEWS
-    //////////////////////////////////////////////////////////////*/
-
-    /**
-     * @dev Get the number of LP tokens pending redemption for a specific LP token.
-     * @return The number of LP tokens pending redemption, adjusted to the contract's decimals.
-     */
-    function getLpTokensPendingRedemption() external view returns (uint256) {
-        return escrowedMapleShares * 10 ** adjustedDecimals;
-    }
-
-    /**
-     * @dev Get the total assets represented by a given amount of LP tokens for a specific asset.
-     * @param _lpTokens The amount of LP tokens to convert.
-     * @return The total assets represented by the LP tokens, adjusted to the contract's decimals, or an error code if the asset is not supported.
-     */
-    function getAssets(uint256 _lpTokens) external view validInput(_lpTokens) returns (uint256) {
-        return IPool(mapleUSDCPool).convertToAssets(_lpTokens / 10 ** adjustedDecimals);
-    }
-
-    /**
-     * @dev Get the total assets with unrealized losses(from Maple Protocol's loans) represented by a given amount of LP tokens for a specific asset.
-     * @param _lpTokens The amount of LP tokens to convert.
-     * @return The total assets with unrealized losses represented by the LP tokens, adjusted to the contract's decimals, or an error code if the asset is not supported.
-     */
-    function getAssetsWithUnrealisedLosses(uint256 _lpTokens) external view validInput(_lpTokens) returns (uint256) {
-        return IPool(mapleUSDCPool).convertToExitAssets(_lpTokens / 10 ** adjustedDecimals);
-    }
-
-    /**
-     * @dev Get the number of shares (issued by Maple protocol pool to the Loan Manager) represented by a given amount of an asset.
-     * @param _amount The amount of the asset to convert.
-     * @return The number of shares represented by the amount of the asset, or an error code if the asset is not supported.
-     */
-    function getShares(uint256 _amount) external view validInput(_amount) returns (uint256) {
-        return IPool(mapleUSDCPool).convertToShares(_amount);
-    }
-
-    /**
-     * @dev Get the number of exit shares represented by a given amount of an asset.
-     * @param _amount The amount of the asset to convert.
-     * @return The number of exit shares represented by the amount of the asset, or an error code if the asset is not supported.
-     */
-    function getExitShares(uint256 _amount) external view validInput(_amount) returns (uint256) {
-        return IPool(mapleUSDCPool).convertToExitShares(_amount);
-    }
-
-    /**
-     * @dev Get the total unrealized losses (from Maple Protocol's loans) for a specific asset within the Maple Protocol pool.
-     * @return The total unrealized losses for the asset, or an error code if the asset is not supported.
-     */
-    function getUnrealizedLossesMaple() external view returns (uint256) {
-        return IPool(mapleUSDCPool).unrealizedLosses();
-    }
-
-    /**
-     * @dev Get the total amount for a specific asset within the Maple Protocol pool.
-     * @return The total amount for the asset, or an error code if the asset is not supported.
-     */
-    function getTotalAssetsMaple() external view returns (uint256) {
-        return IPool(mapleUSDCPool).totalAssets();
-    }
-
-    /**
-     * @dev Preview the redemption of assets based on the given asset and number of LP tokens.
-     * @notice This function returns correct value only when a redemption has been requested and when called within the redemption window.
-     * @param _lpTokens The number of LP tokens to be redeemed.
-     * @return The previewed amount of redeemed assets, or an error code if the asset is not supported.
-     */
-    function previewRedeem(uint256 _lpTokens) external view returns (uint256) {
-        return IPool(mapleUSDCPool).previewRedeem(_lpTokens / 10 ** 12);
-    }
-
-    /**
-     * @dev Preview the deposit of assets based on the given asset and amount.
-     * @param _amount The amount of assets to be deposited.
-     * @return The previewed amount of shares that would be minted to the Loan Manager, or an error code if the asset is not supported.
-     */
-    function previewDepositAssets(uint256 _amount) external view returns (uint256) {
-        return IPool(mapleUSDCPool).previewDeposit(_amount);
-    }
-
-    /**
-     * @dev Check if a deposit amount is valid based on the liquidity cap and total assets in the Maple Protocol pool.
-     * @param _amount The amount to deposit.
-     * @param _pool The address of the Maple Protocol pool contract.
-     * @param _poolManager The address of the Maple Protocol pool manager contract.
-     * @return true if the deposit amount is valid; otherwise, false.
-     */
-    function isValidDepositAmount(uint256 _amount, address _pool, address _poolManager) public view returns (bool) {
-        bytes memory val = _poolManager.functionStaticCall(abi.encodeWithSignature("liquidityCap()"));
-        uint256 upperBound = uint256(bytes32(val));
-        uint256 totalAssets = IPool(_pool).totalAssets();
-        uint256 shares = IPool(_pool).previewDeposit(_amount);
-        return (shares > 0) && (_amount < (upperBound - totalAssets)) ? true : false;
-    }
-
-    /*//////////////////////////////////////////////////////////////
-    ADMIN FUNCTIONS
-    //////////////////////////////////////////////////////////////*/
-
-    function redeemManual(uint256 _shares) external onlyAdmin nonReentrant {
-        _redeemMapleCashManual(_shares, usdc, mapleUSDCPool, address(lUSDC));
-    }
-
-    function _redeemMapleCashManual(uint256 _shares, address _asset, address _pool, address _lpToken) internal {
-        // uint256 _shares = escrowedMapleShares;
-
-        uint256 stablesRedeemed = IPool(_pool).redeem(_shares, nstblHub, address(this));
-        assetsRedeemed += stablesRedeemed;
-        IERC20Helper(_lpToken).burn(nstblHub, (_shares) * 10 ** adjustedDecimals);
-        emit Redeem(_asset, _shares, assetsRedeemed);
-    }
-
-    function getAirdroppedTokens(address _asset) external view returns (uint256 _value) {
-        _value = IERC20Helper(_asset).balanceOf(address(this));
-    }
-
-    function withdrawTokens(address _asset, uint256 _amount, address _destination) external authorizedCaller {
-        IERC20Helper(_asset).safeTransfer(_destination, _amount);
-    }
-
-    function getMaturedAssets() external view returns (uint256 _value) {
-        _value =
-            IPool(mapleUSDCPool).convertToAssets(IPool(mapleUSDCPool).balanceOf(address(this))) * 10 ** adjustedDecimals;
-    }
-
-    function getLPTotalSupply() external view returns (uint256 _value) {
-        _value = lUSDC.totalSupply();
-    }
-
-    function getRevision() internal pure virtual override returns (uint256) {
-        return REVISION;
-    }
-
-    function getVersion() public pure returns (uint256 _version) {
-        _version = getRevision();
-    }
-
-    function getLocked() public view returns (uint256) {
-        return _locked;
-    }
-}
+// // SPDX-License-Identifier: BUSL-1.1
+// pragma solidity 0.8.21;
+
+// import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+// import "@openzeppelin/contracts/utils/Address.sol";
+// import { VersionedInitializable } from "../VersionedInitializable.sol";
+// import {
+//     IPool,
+//     IERC20Helper,
+//     IWithdrawalManagerStorage,
+//     IWithdrawalManager,
+//     IACLManager,
+//     TokenLP,
+//     LoanManagerStorageV2
+// } from "./LoanManagerStorageV2.sol";
+
+// // This contract is just to test upgrade functionality and will not be used in production
+// contract LoanManagerV2 is LoanManagerStorageV2, VersionedInitializable {
+//     using SafeERC20 for IERC20Helper;
+//     using Address for address;
+
+//     uint256 internal constant REVISION = 222;
+//     uint256 private _locked;
+
+//     /*//////////////////////////////////////////////////////////////
+//     MODIFIERS
+//     //////////////////////////////////////////////////////////////*/
+
+//     /**
+//      * @dev Modifier to ensure that only authorized callers can execute a function.
+//      */
+//     modifier authorizedCaller() {
+//         require(IACLManager(aclManager).authorizedCallersLoanManager(msg.sender), "Loan Manager: unAuth Hub");
+//         _;
+//     }
+
+//     /**
+//      * @dev Modifier to ensure that only the admin can execute a function.
+//      */
+//     modifier onlyAdmin() {
+//         require(msg.sender == IACLManager(aclManager).admin(), "LM: unAuth Admin");
+//         _;
+//     }
+
+//     /**
+//      * @dev Modifier to validate input parameters.
+//      */
+//     modifier validInput(uint256 _amount) {
+//         require(_amount > 0, "LM: Insufficient amount");
+//         _;
+//     }
+
+//     /**
+//      * @dev Modifier to prevent reentrancy attacks.
+//      */
+//     modifier nonReentrant() {
+//         require(_locked == 1, "LM:LOCKED");
+
+//         _locked = 2;
+
+//         _;
+
+//         _locked = 1;
+//     }
+
+//     /*//////////////////////////////////////////////////////////////
+//     CONSTRUCTOR
+//     //////////////////////////////////////////////////////////////*/
+
+//     /**
+//      * @dev Constructor to set immutables the LoanManager contract.
+//      */
+//     constructor() {
+//         usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
+//     }
+
+//     function initialize(uint256 _newVar) external initializer {
+//         newVar = _newVar;
+//     }
+
+//     /*//////////////////////////////////////////////////////////////
+//     LP FUNCTIONS
+//     //////////////////////////////////////////////////////////////*/
+
+//     /**
+//      * @dev Deposit assets into the Maple Protocol pool and mint LP tokens (lUSDC) to the NSTBL Hub.
+//      * @notice The LP tokens corresponding to the shares issued by the Maple Protocol pool are minted.
+//      * @param _amount The amount of the asset to deposit.
+//      */
+//     function deposit(uint256 _amount) external authorizedCaller nonReentrant {
+//         _depositMapleCash(_amount, usdc, mapleUSDCPool, address(lUSDC), MAPLE_POOL_MANAGER_USDC);
+//     }
+
+//     /**
+//      * @dev Request the redemption of LP tokens issued. (lUSDC)
+//      * @notice The shares corresponding to the LP tokens are requested for redemption from the Maple Protocol pool.
+//      * @param _lpTokens The amount of LP tokens to redeem.
+//      */
+//     function requestRedeem(uint256 _lpTokens) external authorizedCaller nonReentrant validInput(_lpTokens) {
+//         _requestRedeemMapleCash(_lpTokens, usdc, mapleUSDCPool);
+//     }
+
+//     /**
+//      * @dev Redeem LP tokens issued. (lUSDC)
+//      * @notice The shares corresponding to the LP tokens that were requested for redemption are redeemed from the Maple Protocol pool.
+//      * @notice The shares are burned in the Maple Protocol pool contract and the LP tokens are burned here.
+//      */
+//     function redeem() external authorizedCaller nonReentrant {
+//         require(awaitingRedemption, "LM: No redemption requested");
+//         _redeemMapleCash(usdc, mapleUSDCPool, address(lUSDC), MAPLE_WITHDRAWAL_MANAGER_USDC);
+//     }
+
+//     /**
+//      * @dev Remove Locked Maple Shares (during request redemption).
+//      * @notice The shares corresponding to the LP tokens that were requested for redemption are removed from the Maple Protocol pool.
+//      * @notice The shares are transferred Maple Protocol's withdrawal manager contract back to Nealthy's loan Manager.
+//      */
+//     function remove() external authorizedCaller nonReentrant {
+//         require(awaitingRedemption, "LM: No Tokens to remove");
+//         _removeMapleCash(usdc, mapleUSDCPool, MAPLE_WITHDRAWAL_MANAGER_USDC);
+//     }
+
+//     /*//////////////////////////////////////////////////////////////
+//     INTERNALS
+//     //////////////////////////////////////////////////////////////*/
+
+//     /**
+//      * @dev Internal function to deposit assets into the Maple Protocol pool and mint LP tokens.
+//      * @param _amount The amount of the asset to deposit.
+//      * @param _asset The address of the asset being deposited.
+//      * @param _pool The address of the Maple Protocol pool.
+//      * @param _lpToken The address of the LP token associated with the pool.
+//      * @param _poolManager The address of the Maple Protocol pool manager contract.
+//      * @notice This function checks if the deposit amount is valid, transfers the assets from the sender to this contract, approves the pool to spend the assets, updates relevant accounting data, and emits a `Deposit` event.
+//      */
+//     function _depositMapleCash(uint256 _amount, address _asset, address _pool, address _lpToken, address _poolManager)
+//         internal
+//     {
+//         require(isValidDepositAmount(_amount, _pool, _poolManager), "LM: Invalid amount");
+//         uint256 lpTokens;
+//         uint256 sharesReceived;
+//         IERC20Helper(_asset).safeTransferFrom(msg.sender, address(this), _amount);
+//         IERC20Helper(_asset).safeIncreaseAllowance(_pool, _amount);
+
+//         totalAssetsReceived += _amount;
+//         uint256 balBefore = IPool(_pool).balanceOf(address(this));
+//         IPool(_pool).deposit(_amount, address(this));
+//         sharesReceived = IPool(_pool).balanceOf(address(this)) - balBefore;
+//         totalSharesReceived += sharesReceived;
+//         lpTokens = sharesReceived * 10 ** adjustedDecimals;
+//         totalLPTokensMinted += lpTokens;
+//         IERC20Helper(_lpToken).mint(nstblHub, lpTokens);
+//         emit Deposit(_asset, _amount, lpTokens, sharesReceived);
+//     }
+
+//     /**
+//      * @dev Internal function to request the redemption of LP tokens issued. (lUSDC)
+//      * @param _lpTokens The amount of LP tokens to redeem.
+//      * @param _asset The address of the asset to redeem.
+//      * @param _pool The address of the Maple Protocol pool.
+//      * @notice This function checks if redemption is pending and if there are sufficient shares to redeem, records the escrowed shares, and emits a `RequestRedeem` event.
+//      */
+//     function _requestRedeemMapleCash(uint256 _lpTokens, address _asset, address _pool) internal {
+//         require(!awaitingRedemption, "LM: Redemption Pending");
+//         require(IPool(_pool).balanceOf(address(this)) >= _lpTokens / 10 ** adjustedDecimals, "LM: Insufficient Shares");
+//         escrowedMapleShares = IPool(_pool).requestRedeem(_lpTokens / 10 ** adjustedDecimals, address(this));
+//         awaitingRedemption = true;
+//         emit RequestRedeem(_asset, _lpTokens, escrowedMapleShares);
+//     }
+
+//     /**
+//      * @dev Internal function to Redeem LP tokens issued. (lUSDC)
+//      * @param _asset The address of the asset to redeem.
+//      * @param _pool The address of the Maple Protocol pool.
+//      * @param _lpToken The address of the LP token associated with the pool.
+//      * @param _withdrawManager The address of the withdrawal manager contract.
+//      * @notice This function redeems Maple Protocol tokens, burns the associated LP tokens, updates relevant accounting data, and emits a `Redeem` event.
+//      */
+//     function _redeemMapleCash(address _asset, address _pool, address _lpToken, address _withdrawManager) internal {
+//         uint256 exitCycleId = IWithdrawalManagerStorage(_withdrawManager).exitCycleId(address(this));
+//         (uint256 windowStart, uint256 windowEnd) = IWithdrawalManager(_withdrawManager).getWindowAtId(exitCycleId);
+//         uint256 _shares = escrowedMapleShares;
+
+//         require(block.timestamp >= windowStart && block.timestamp < windowEnd, "LM: Not in Window");
+
+//         uint256 stablesRedeemed = IPool(_pool).redeem(_shares, nstblHub, address(this));
+//         assetsRedeemed += stablesRedeemed;
+//         escrowedMapleShares = IWithdrawalManagerStorage(_withdrawManager).lockedShares(address(this));
+//         totalLPTokensBurned += (_shares - escrowedMapleShares) * 10 ** adjustedDecimals;
+//         IERC20Helper(_lpToken).burn(nstblHub, (_shares - escrowedMapleShares) * 10 ** adjustedDecimals);
+//         if (escrowedMapleShares == 0) {
+//             awaitingRedemption = false;
+//         }
+//         emit Redeem(_asset, _shares, assetsRedeemed);
+//     }
+
+//     /**
+//      * @dev Internal function to remove locked Maple Shares.
+//      * @param _asset The address of the asset to redeem.
+//      * @param _pool The address of the Maple Protocol pool.
+//      * @param _withdrawManager The address of the withdrawal manager contract.
+//      * @notice This function transfers locked Maple Shares from Maple Protocol to loanManager, updates relevant accounting data, and emits a `Remove` event.
+//      */
+//     function _removeMapleCash(address _asset, address _pool, address _withdrawManager) internal {
+//         uint256 exitCycleId = IWithdrawalManagerStorage(_withdrawManager).exitCycleId(address(this));
+//         (, uint256 windowEnd) = IWithdrawalManager(_withdrawManager).getWindowAtId(exitCycleId);
+//         uint256 _shares = escrowedMapleShares;
+
+//         require(block.timestamp > windowEnd, "LM: Redemption Pending");
+
+//         uint256 sharesRemoved = IPool(_pool).removeShares(_shares, address(this));
+//         escrowedMapleShares -= sharesRemoved;
+
+//         if (escrowedMapleShares == 0) {
+//             awaitingRedemption = false;
+//         }
+
+//         emit Removed(_asset, _shares);
+//     }
+
+//     /*//////////////////////////////////////////////////////////////
+//     VIEWS
+//     //////////////////////////////////////////////////////////////*/
+
+//     /**
+//      * @dev Get the number of LP tokens pending redemption for a specific LP token.
+//      * @return The number of LP tokens pending redemption, adjusted to the contract's decimals.
+//      */
+//     function getLpTokensPendingRedemption() external view returns (uint256) {
+//         return escrowedMapleShares * 10 ** adjustedDecimals;
+//     }
+
+//     /**
+//      * @dev Get the total assets represented by a given amount of LP tokens for a specific asset.
+//      * @param _lpTokens The amount of LP tokens to convert.
+//      * @return The total assets represented by the LP tokens, adjusted to the contract's decimals, or an error code if the asset is not supported.
+//      */
+//     function getAssets(uint256 _lpTokens) external view validInput(_lpTokens) returns (uint256) {
+//         return IPool(mapleUSDCPool).convertToAssets(_lpTokens / 10 ** adjustedDecimals);
+//     }
+
+//     /**
+//      * @dev Get the total assets with unrealized losses(from Maple Protocol's loans) represented by a given amount of LP tokens for a specific asset.
+//      * @param _lpTokens The amount of LP tokens to convert.
+//      * @return The total assets with unrealized losses represented by the LP tokens, adjusted to the contract's decimals, or an error code if the asset is not supported.
+//      */
+//     function getAssetsWithUnrealisedLosses(uint256 _lpTokens) external view validInput(_lpTokens) returns (uint256) {
+//         return IPool(mapleUSDCPool).convertToExitAssets(_lpTokens / 10 ** adjustedDecimals);
+//     }
+
+//     /**
+//      * @dev Get the number of shares (issued by Maple protocol pool to the Loan Manager) represented by a given amount of an asset.
+//      * @param _amount The amount of the asset to convert.
+//      * @return The number of shares represented by the amount of the asset, or an error code if the asset is not supported.
+//      */
+//     function getShares(uint256 _amount) external view validInput(_amount) returns (uint256) {
+//         return IPool(mapleUSDCPool).convertToShares(_amount);
+//     }
+
+//     /**
+//      * @dev Get the number of exit shares represented by a given amount of an asset.
+//      * @param _amount The amount of the asset to convert.
+//      * @return The number of exit shares represented by the amount of the asset, or an error code if the asset is not supported.
+//      */
+//     function getExitShares(uint256 _amount) external view validInput(_amount) returns (uint256) {
+//         return IPool(mapleUSDCPool).convertToExitShares(_amount);
+//     }
+
+//     /**
+//      * @dev Get the total unrealized losses (from Maple Protocol's loans) for a specific asset within the Maple Protocol pool.
+//      * @return The total unrealized losses for the asset, or an error code if the asset is not supported.
+//      */
+//     function getUnrealizedLossesMaple() external view returns (uint256) {
+//         return IPool(mapleUSDCPool).unrealizedLosses();
+//     }
+
+//     /**
+//      * @dev Get the total amount for a specific asset within the Maple Protocol pool.
+//      * @return The total amount for the asset, or an error code if the asset is not supported.
+//      */
+//     function getTotalAssetsMaple() external view returns (uint256) {
+//         return IPool(mapleUSDCPool).totalAssets();
+//     }
+
+//     /**
+//      * @dev Preview the redemption of assets based on the given asset and number of LP tokens.
+//      * @notice This function returns correct value only when a redemption has been requested and when called within the redemption window.
+//      * @param _lpTokens The number of LP tokens to be redeemed.
+//      * @return The previewed amount of redeemed assets, or an error code if the asset is not supported.
+//      */
+//     function previewRedeem(uint256 _lpTokens) external view returns (uint256) {
+//         return IPool(mapleUSDCPool).previewRedeem(_lpTokens / 10 ** 12);
+//     }
+
+//     /**
+//      * @dev Preview the deposit of assets based on the given asset and amount.
+//      * @param _amount The amount of assets to be deposited.
+//      * @return The previewed amount of shares that would be minted to the Loan Manager, or an error code if the asset is not supported.
+//      */
+//     function previewDepositAssets(uint256 _amount) external view returns (uint256) {
+//         return IPool(mapleUSDCPool).previewDeposit(_amount);
+//     }
+
+//     /**
+//      * @dev Check if a deposit amount is valid based on the liquidity cap and total assets in the Maple Protocol pool.
+//      * @param _amount The amount to deposit.
+//      * @param _pool The address of the Maple Protocol pool contract.
+//      * @param _poolManager The address of the Maple Protocol pool manager contract.
+//      * @return true if the deposit amount is valid; otherwise, false.
+//      */
+//     function isValidDepositAmount(uint256 _amount, address _pool, address _poolManager) public view returns (bool) {
+//         bytes memory val = _poolManager.functionStaticCall(abi.encodeWithSignature("liquidityCap()"));
+//         uint256 upperBound = uint256(bytes32(val));
+//         uint256 totalAssets = IPool(_pool).totalAssets();
+//         uint256 shares = IPool(_pool).previewDeposit(_amount);
+//         return (shares > 0) && (_amount < (upperBound - totalAssets)) ? true : false;
+//     }
+
+//     /*//////////////////////////////////////////////////////////////
+//     ADMIN FUNCTIONS
+//     //////////////////////////////////////////////////////////////*/
+
+//     function redeemManual(uint256 _shares) external onlyAdmin nonReentrant {
+//         _redeemMapleCashManual(_shares, usdc, mapleUSDCPool, address(lUSDC));
+//     }
+
+//     function _redeemMapleCashManual(uint256 _shares, address _asset, address _pool, address _lpToken) internal {
+//         // uint256 _shares = escrowedMapleShares;
+
+//         uint256 stablesRedeemed = IPool(_pool).redeem(_shares, nstblHub, address(this));
+//         assetsRedeemed += stablesRedeemed;
+//         IERC20Helper(_lpToken).burn(nstblHub, (_shares) * 10 ** adjustedDecimals);
+//         emit Redeem(_asset, _shares, assetsRedeemed);
+//     }
+
+//     function getAirdroppedTokens(address _asset) external view returns (uint256 _value) {
+//         _value = IERC20Helper(_asset).balanceOf(address(this));
+//     }
+
+//     function withdrawTokens(address _asset, uint256 _amount, address _destination) external authorizedCaller {
+//         IERC20Helper(_asset).safeTransfer(_destination, _amount);
+//     }
+
+//     function getMaturedAssets() external view returns (uint256 _value) {
+//         _value =
+//             IPool(mapleUSDCPool).convertToAssets(IPool(mapleUSDCPool).balanceOf(address(this))) * 10 ** adjustedDecimals;
+//     }
+
+//     function getLPTotalSupply() external view returns (uint256 _value) {
+//         _value = lUSDC.totalSupply();
+//     }
+
+//     function getRevision() internal pure virtual override returns (uint256) {
+//         return REVISION;
+//     }
+
+//     function getVersion() public pure returns (uint256 _version) {
+//         _version = getRevision();
+//     }
+
+//     function getLocked() public view returns (uint256) {
+//         return _locked;
+//     }
+// }
diff --git a/tests/helpers/BaseTest.t.sol b/tests/helpers/BaseTest.t.sol
index 50cece1..8f08af4 100644
--- a/tests/helpers/BaseTest.t.sol
+++ b/tests/helpers/BaseTest.t.sol
@@ -4,7 +4,7 @@ pragma solidity ^0.8.13;
 import { Test, console } from "forge-std/Test.sol";
 import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
 import { LoanManager } from "../../contracts/LoanManager.sol";
-import { LoanManagerV2 } from "../../contracts/upgradeable/test/LoanManagerV2.sol";
+// import { LoanManagerV2 } from "../../contracts/upgradeable/test/LoanManagerV2.sol";
 import { ACLManager } from "@nstbl-acl-manager/contracts/ACLManager.sol";
 import { ProxyAdmin } from "../../contracts/upgradeable/ProxyAdmin.sol";
 import {
@@ -14,6 +14,7 @@ import {
 import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
 import { IPoolManager } from "../../contracts/interfaces/maple/IPoolManager.sol";
+import { IPoolPermissionManager } from "../../contracts/interfaces/maple/IPoolPermissionManager.sol";
 import { IWithdrawalManager, IWithdrawalManagerStorage } from "../../contracts/interfaces/maple/IWithdrawalManager.sol";
 import { IPool } from "../../contracts/interfaces/maple/IPool.sol";
 import { Utils } from "./Utils.sol";
@@ -30,7 +31,7 @@ contract BaseTest is Utils {
 
     ACLManager public aclManager;
     LoanManager public lmImpl1;
-    LoanManagerV2 public lmImpl2;
+    // LoanManagerV2 public lmImpl2;
 
     LoanManager public loanManager;
     // Token public token;
@@ -40,6 +41,7 @@ contract BaseTest is Utils {
 
     IPool public usdcPool;
     IPoolManager public poolManagerUSDC;
+    IPoolPermissionManager public poolPermissionManagerUSDC;
     IWithdrawalManager public withdrawalManagerUSDC;
     uint256 mainnetFork;
 
@@ -60,7 +62,7 @@ contract BaseTest is Utils {
         );
         proxyAdmin = new ProxyAdmin(owner);
         lmImpl1 = new LoanManager();
-        lmImpl2 = new LoanManagerV2();
+        // lmImpl2 = new LoanManagerV2();
         bytes memory data = abi.encodeCall(lmImpl1.initialize, (address(aclManager), MAPLE_USDC_CASH_POOL));
         loanManagerProxy = new TransparentUpgradeableProxy(address(lmImpl1), address(proxyAdmin), data);
         loanManager = LoanManager(address(loanManagerProxy));
@@ -71,6 +73,7 @@ contract BaseTest is Utils {
         usdc = IERC20(USDC);
         usdcPool = IPool(MAPLE_USDC_CASH_POOL);
         poolManagerUSDC = IPoolManager(MAPLE_POOL_MANAGER_USDC);
+        poolPermissionManagerUSDC = IPoolPermissionManager(MAPLE_POOL_PERMISSION_MANAGER);
         withdrawalManagerUSDC = IWithdrawalManager(WITHDRAWAL_MANAGER_USDC);
 
         vm.label(address(loanManager), "LoanManager");
@@ -78,16 +81,23 @@ contract BaseTest is Utils {
         vm.label(address(usdcPool), "USDC Pool");
         vm.label(poolDelegateUSDC, "poolDelegate USDC");
         vm.label(address(poolManagerUSDC), "poolManager USDC");
+
+        vm.prank(poolDelegateUSDC);
+        withdrawalManagerUSDC.setManualWithdrawal(address(loanManager), true);
     }
 
     function _setAllowedLender(address _delegate) internal {
         bool out;
         vm.startPrank(_delegate);
 
-        poolManagerUSDC.setAllowedLender(address(loanManager), true);
-        (out,) = address(poolManagerUSDC).staticcall(abi.encodeWithSignature("isValidLender(address)", user));
+        address[] memory lenders = new address[](1);
+        bool[] memory val = new bool[](1);
+        lenders[0] = address(loanManager);
+        val[0] = true;
+        poolPermissionManagerUSDC.setLenderAllowlist(MAPLE_POOL_MANAGER_USDC, lenders, val);
+        // (out,) = address(poolManagerUSDC).staticcall(abi.encodeWithSignature("isValidLender(address)", user));
 
-        assertTrue(out);
+        // assertTrue(out);
         vm.stopPrank();
     }
 
diff --git a/tests/helpers/Utils.sol b/tests/helpers/Utils.sol
index 75abe01..c3797d9 100644
--- a/tests/helpers/Utils.sol
+++ b/tests/helpers/Utils.sol
@@ -11,7 +11,9 @@ contract Utils is Test {
     address public NSTBL_HUB = 0x749f88e87EaEb030E478164cFd3681E27d0bcB42;
     address public MAPLE_USDC_CASH_POOL = 0xfe119e9C24ab79F1bDd5dd884B86Ceea2eE75D92;
     address public MAPLE_POOL_MANAGER_USDC = 0x219654A61a0BC394055652986BE403fa14405Bb8;
-    address public WITHDRAWAL_MANAGER_USDC = 0x1146691782c089bCF0B19aCb8620943a35eebD12;
+    address public MAPLE_POOL_PERMISSION_MANAGER = 0xBe10aDcE8B6E3E02Db384E7FaDA5395DD113D8b3;
+    // address public WITHDRAWAL_MANAGER_USDC = 0x1146691782c089bCF0B19aCb8620943a35eebD12;
+    address public WITHDRAWAL_MANAGER_USDC = 0x447dcEa1d616f792645ed6E71bC32955A0dBcbAa;
 
     // EOA addresses
     address owner = address(123);
diff --git a/tests/unit/LoanManager.t.sol b/tests/unit/LoanManager.t.sol
index 6db81ca..c70bb18 100644
--- a/tests/unit/LoanManager.t.sol
+++ b/tests/unit/LoanManager.t.sol
@@ -22,28 +22,6 @@ contract TestProxy is BaseTest {
         assertEq(ERC20(address(loanManager.lUSDC())).name(), "Loan Manager USDC");
     }
 
-    function test_wrongProxyUpgrade() external {
-        vm.startPrank(proxyAdmin.owner());
-        bytes memory data = abi.encodeCall(lmImpl2.initialize, (1e3));
-        proxyAdmin.upgradeAndCall(ITransparentUpgradeableProxy(address(loanManagerProxy)), address(lmImpl2), data);
-        vm.stopPrank();
-
-        LoanManagerV2 loanManager2 = LoanManagerV2(address(loanManagerProxy));
-        assertEq(loanManager2.aclManager(), address(aclManager));
-        assertEq(loanManager2.nstblHub(), NSTBL_HUB);
-        assertEq(loanManager2.mapleUSDCPool(), MAPLE_USDC_CASH_POOL);
-        assertEq(loanManager2.usdc(), USDC);
-        assertEq(loanManager2.MAPLE_POOL_MANAGER_USDC(), MAPLE_POOL_MANAGER_USDC);
-        assertEq(loanManager2.MAPLE_WITHDRAWAL_MANAGER_USDC(), WITHDRAWAL_MANAGER_USDC);
-        assertEq(uint256(vm.load(address(loanManager2), bytes32(uint256(0)))), 222);
-        assertEq(loanManager2.getVersion(), 222);
-        assertEq(loanManager2.versionSlot(), 222);
-        assertEq(ERC20(address(loanManager2.lUSDC())).name(), "Loan Manager USDC");
-        assertEq(loanManager2.newVar(), 1e3);
-        assertEq(loanManager2.getLocked(), 0, "LOCKED VAR");
-        assertEq(uint256(vm.load(address(loanManager2), bytes32(uint256(62)))), 0, "T2");
-    }
-
     function test_wrongSetup() external {
         vm.startPrank(aclManager.admin());
         vm.expectRevert("LM:INVALID_ADDRESS");
@@ -216,40 +194,51 @@ contract TestRedeem is BaseTest {
         // time warp
         vm.warp(block.timestamp + 2 weeks);
 
-        vm.expectRevert("LM: No redemption requested");
-        loanManager.getRedemptionWindow();
+        // vm.expectRevert("LM: No redemption requested");
+        // loanManager.getRedemptionWindow();
         uint256 lmUSDC = lusdc.balanceOf(NSTBL_HUB);
         vm.startPrank(NSTBL_HUB);
         loanManager.requestRedeem(lmUSDC);
         assertEq(usdcPool.balanceOf(address(loanManager)), 0);
+        (, uint256 lockedShares) =
+            withdrawalManagerUSDC.requests(withdrawalManagerUSDC.requestIds(address(loanManager)));
+        console.log("Shares: ", lmUSDC, lockedShares, withdrawalManagerUSDC.lockedShares(address(loanManager)));
+        console.log("Request Id: ", withdrawalManagerUSDC.requestIds(address(loanManager)));
+        console.log("Manual Shares: ", withdrawalManagerUSDC.manualSharesAvailable(address(loanManager)));
+        console.log("If manual withdraw: ", withdrawalManagerUSDC.isManualWithdrawal(address(loanManager)));
+        console.log("If in exit window: ", withdrawalManagerUSDC.isInExitWindow(address(loanManager)));
 
-        uint256 _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        uint256 _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (uint256 exitWindowStart,) = loanManager.getRedemptionWindow();
+        vm.stopPrank();
 
-        vm.expectRevert("LM: Not in Window");
-        loanManager.redeem();
+        // auto redemption
+        uint256 balBefore = IERC20(USDC).balanceOf(NSTBL_HUB);
+        vm.prank(poolDelegateUSDC);
+        withdrawalManagerUSDC.processRedemptions(lmUSDC / 10 ** 12);
+        uint256 balAfter = IERC20(USDC).balanceOf(NSTBL_HUB);
 
-        vm.warp(exitWindowStart);
+        console.log("If in exit window: ", withdrawalManagerUSDC.isInExitWindow(address(loanManager)));
+        console.log("USDC balances: ", balBefore, balAfter);
+        console.log("Manual Shares: ", withdrawalManagerUSDC.manualSharesAvailable(address(loanManager)));
+        console.log("Locked Shares: ", withdrawalManagerUSDC.lockedShares(address(loanManager)));
 
+        //now performing manual redeem
+        vm.startPrank(NSTBL_HUB);
         uint256 expectedUSDC = loanManager.getAssetsWithUnrealisedLosses(lmUSDC);
         uint256 stablesRedeemed = loanManager.redeem();
+        console.log(stablesRedeemed, expectedUSDC, "check stables received");
         assertEq(stablesRedeemed, expectedUSDC, "check stables received");
-        assertEq(lusdc.balanceOf(NSTBL_HUB), loanManager.escrowedMapleShares() * 10 ** 12, "check lUSDC balance");
-        assertEq(lusdc.totalSupply(), loanManager.escrowedMapleShares() * 10 ** 12, "check lUSDC total supply");
-        console.log("lUSDC pending redemption - ", loanManager.getLpTokensPendingRedemption());
-        if (loanManager.escrowedMapleShares() == 0) {
-            assertFalse(loanManager.awaitingRedemption());
-        } else {
-            assertTrue(loanManager.awaitingRedemption());
-        }
+
         vm.stopPrank();
+
+        console.log("Request Id: ", withdrawalManagerUSDC.requestIds(address(loanManager)));
+        console.log("If in exit window: ", withdrawalManagerUSDC.isInExitWindow(address(loanManager)));
+        console.log("Manual Shares: ", withdrawalManagerUSDC.manualSharesAvailable(address(loanManager)));
     }
 
     function test_redeem_USDC_fullLP_pass_fuzz(uint256 amount) external {
         // Constraint input amount
-        vm.assume(amount < _getUpperBoundDeposit(MAPLE_USDC_CASH_POOL, address(poolManagerUSDC)));
+        // vm.assume(amount < _getUpperBoundDeposit(MAPLE_USDC_CASH_POOL, address(poolManagerUSDC)));
+        vm.assume(amount < 1e5 * 1e6);
         uint256 shares = usdcPool.previewDeposit(amount);
         vm.assume(shares > 0);
 
@@ -262,20 +251,20 @@ contract TestRedeem is BaseTest {
         assertEq(lusdc.balanceOf(NSTBL_HUB), lmUSDC);
         assertEq(lusdc.balanceOf(address(loanManager)), 0);
         assertEq(usdcPool.balanceOf(address(loanManager)), 0);
+        vm.stopPrank();
 
-        uint256 _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        uint256 _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (uint256 exitWindowStart,) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
-
-        vm.expectRevert("LM: Not in Window");
-        loanManager.redeem();
+        vm.prank(poolDelegateUSDC);
+        withdrawalManagerUSDC.processRedemptions(lmUSDC / 10 ** 12);
+        assertEq(lmUSDC / 1e12, withdrawalManagerUSDC.manualSharesAvailable(address(loanManager)));
 
-        vm.warp(exitWindowStart);
+        vm.warp(block.timestamp + 100 days);
 
+        vm.startPrank(NSTBL_HUB);
         loanManager.redeem();
-        assertEq(lusdc.balanceOf(NSTBL_HUB), loanManager.escrowedMapleShares() * 10 ** 12);
-        assertEq(lusdc.totalSupply(), loanManager.escrowedMapleShares() * 10 ** 12);
+        // assertEq(lusdc.balanceOf(NSTBL_HUB), loanManager.escrowedMapleShares() * 10 ** 12);
+        assertEq(lusdc.balanceOf(NSTBL_HUB), 0);
+        // assertEq(lusdc.totalSupply(), loanManager.escrowedMapleShares() * 10 ** 12);
+        assertEq(lusdc.totalSupply(), 0);
         if (loanManager.escrowedMapleShares() == 0) {
             assertFalse(loanManager.awaitingRedemption());
         } else {
@@ -294,26 +283,26 @@ contract TestRedeem is BaseTest {
         vm.assume(redeemAmount < IPool(MAPLE_USDC_CASH_POOL).balanceOf(address(loanManager)));
         redeemAmount *= 1e12;
         vm.assume(redeemAmount > 0);
-
         uint256 lmUSDC = lusdc.balanceOf(NSTBL_HUB);
-
+        console.log(amount, redeemAmount, lmUSDC);
         vm.startPrank(NSTBL_HUB);
         loanManager.requestRedeem(redeemAmount);
 
         assertEq(usdcPool.balanceOf(address(loanManager)), (lmUSDC - redeemAmount) / 1e12, "loanmanager");
         assertEq(redeemAmount, loanManager.escrowedMapleShares() * 1e12);
+        vm.stopPrank();
 
-        uint256 _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        uint256 _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (uint256 exitWindowStart,) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
+        vm.prank(poolDelegateUSDC);
+        withdrawalManagerUSDC.processRedemptions(redeemAmount / 10 ** 12);
 
-        vm.expectRevert("LM: Not in Window");
-        loanManager.redeem();
+        vm.warp(block.timestamp + 100 days);
 
-        vm.warp(exitWindowStart);
+        vm.startPrank(NSTBL_HUB);
+        uint256 expectedUSDC = loanManager.getAssetsWithUnrealisedLosses(redeemAmount);
+        uint256 usdcReceived = loanManager.redeem();
+        assertEq(expectedUSDC, usdcReceived);
+        console.log("USDC received: ", expectedUSDC, usdcReceived);
 
-        loanManager.redeem();
         assertEq(lusdc.balanceOf(NSTBL_HUB), lmUSDC - (redeemAmount - loanManager.escrowedMapleShares() * 10 ** 12));
         assertEq(lusdc.totalSupply(), lmUSDC - (redeemAmount - loanManager.escrowedMapleShares() * 10 ** 12));
         if (loanManager.escrowedMapleShares() == 0) {
@@ -324,150 +313,83 @@ contract TestRedeem is BaseTest {
         vm.stopPrank();
     }
 
-    function test_redeem_USDC_missedWindow() external {
-        uint256 amount = 1e7 * 1e6;
-        _investAssets(USDC, amount);
-
-        //no tokens to remove from pool
-        vm.startPrank(NSTBL_HUB);
-        vm.expectRevert("LM: No Tokens to remove");
-        loanManager.remove();
-        vm.stopPrank();
-
-        uint256 wmInitialBal = usdcPool.balanceOf(address(withdrawalManagerUSDC));
-        // time warp
-        vm.warp(block.timestamp + 2 weeks);
-
+    function test_remove_shares() external {
+        _investAssets(USDC, 1e4 * 1e6);
         uint256 lmUSDC = lusdc.balanceOf(NSTBL_HUB);
-        vm.startPrank(NSTBL_HUB);
+        vm.prank(NSTBL_HUB);
         loanManager.requestRedeem(lmUSDC);
-        assertEq(usdcPool.balanceOf(address(loanManager)), 0);
-
-        uint256 _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        uint256 _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (, uint256 exitWindowEnd) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
-
-        vm.expectRevert("LM: Not in Window");
-        loanManager.redeem();
 
-        vm.expectRevert("LM: Redemption Pending");
-        loanManager.remove();
-
-        vm.warp(exitWindowEnd + 100);
-
-        vm.expectRevert("LM: Not in Window");
-        loanManager.redeem();
-        assertEq(usdcPool.balanceOf(address(withdrawalManagerUSDC)), wmInitialBal + lmUSDC / 10 ** 12);
+        assertEq(usdcPool.balanceOf(address(loanManager)), 0);
+        (, uint256 lockedShares) =
+            withdrawalManagerUSDC.requests(withdrawalManagerUSDC.requestIds(address(loanManager)));
+        assertEq(lockedShares, lmUSDC / 1e12);
 
-        //removing shares
+        vm.prank(NSTBL_HUB);
         loanManager.remove();
-        assertEq(usdcPool.balanceOf(address(loanManager)), lmUSDC / 10 ** 12);
-        assertEq(usdcPool.balanceOf(address(withdrawalManagerUSDC)), wmInitialBal);
-        assertEq(loanManager.escrowedMapleShares(), 0);
-        assertEq(loanManager.awaitingRedemption(), false);
+        assertEq(usdcPool.balanceOf(address(loanManager)), lmUSDC / 1e12);
+        (, lockedShares) = withdrawalManagerUSDC.requests(withdrawalManagerUSDC.requestIds(address(loanManager)));
+        assertEq(lockedShares, 0);
+    }
 
-        //Requesting redemption again
+    function test_remove_shares_fail() external {
+        _investAssets(USDC, 1e4 * 1e6);
+        uint256 lmUSDC = lusdc.balanceOf(NSTBL_HUB);
+        vm.prank(NSTBL_HUB);
         loanManager.requestRedeem(lmUSDC);
-        assertEq(usdcPool.balanceOf(address(loanManager)), 0);
-        assertEq(usdcPool.balanceOf(address(withdrawalManagerUSDC)), wmInitialBal + lmUSDC / 10 ** 12);
 
-        _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (uint256 exitWindowStart,) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
-
-        vm.warp(exitWindowStart);
+        assertEq(usdcPool.balanceOf(address(loanManager)), 0);
+        (, uint256 lockedShares) =
+            withdrawalManagerUSDC.requests(withdrawalManagerUSDC.requestIds(address(loanManager)));
+        assertEq(lockedShares, lmUSDC / 1e12);
 
-        //Redeeming requested assets
-        loanManager.redeem();
+        // auto redemption
+        vm.prank(poolDelegateUSDC);
+        withdrawalManagerUSDC.processRedemptions(lmUSDC / 10 ** 12);
 
-        assertEq(lusdc.balanceOf(NSTBL_HUB), loanManager.escrowedMapleShares() * 10 ** 12);
-        assertEq(lusdc.totalSupply(), loanManager.escrowedMapleShares() * 10 ** 12);
-        if (loanManager.escrowedMapleShares() == 0) {
-            assertFalse(loanManager.awaitingRedemption());
-        } else {
-            assertTrue(loanManager.awaitingRedemption());
-        }
+        vm.startPrank(NSTBL_HUB);
+        vm.expectRevert("LM: Not in Queue");
+        loanManager.remove();
         vm.stopPrank();
     }
 
-    function test_redeem_USDC_partialLP_missedWindow_fuzz(uint256 amount, uint256 redeemAmount) external {
-        // Constraint input amount
-        vm.assume(amount < _getUpperBoundDeposit(MAPLE_USDC_CASH_POOL, address(poolManagerUSDC)));
-        uint256 shares = usdcPool.previewDeposit(amount);
-        vm.assume(shares > 0);
+    function test_redeem_USDC_fail() external {
+        uint256 amount = 1e4 * 1e6;
         _investAssets(USDC, amount);
 
-        vm.assume(redeemAmount < IPool(MAPLE_USDC_CASH_POOL).balanceOf(address(loanManager)));
-        redeemAmount *= 1e12;
-        vm.assume(redeemAmount > 0);
-
         // time warp
         vm.warp(block.timestamp + 2 weeks);
 
+        // vm.expectRevert("LM: No redemption requested");
+        // loanManager.getRedemptionWindow();
         uint256 lmUSDC = lusdc.balanceOf(NSTBL_HUB);
-        uint256 wmBalBefore = usdcPool.balanceOf(address(withdrawalManagerUSDC));
         vm.startPrank(NSTBL_HUB);
-        loanManager.requestRedeem(redeemAmount);
-        uint256 wmBalAfter = usdcPool.balanceOf(address(withdrawalManagerUSDC));
-
-        assertEq(usdcPool.balanceOf(address(loanManager)), (lmUSDC - redeemAmount) / 1e12);
-        assertEq(redeemAmount, loanManager.escrowedMapleShares() * 1e12);
-        assertEq(wmBalAfter - wmBalBefore, redeemAmount / 1e12);
-
-        uint256 _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        uint256 _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (, uint256 exitWindowEnd) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
-
-        vm.expectRevert("LM: Not in Window");
-        loanManager.redeem();
-
-        vm.warp(exitWindowEnd + 100);
+        loanManager.requestRedeem(lmUSDC);
+        assertEq(usdcPool.balanceOf(address(loanManager)), 0);
+        vm.stopPrank();
 
-        vm.expectRevert("LM: Not in Window");
-        loanManager.redeem();
-        assertEq(wmBalAfter - wmBalBefore, redeemAmount / 10 ** 12);
+        //now performing manual redeem
+        vm.startPrank(NSTBL_HUB);
+        vm.expectRevert("LM: No shares to redeem");
+        uint256 stablesRedeemed = loanManager.redeem();
+        vm.stopPrank();
+    }
 
-        //removing shares
-        wmBalBefore = usdcPool.balanceOf(address(withdrawalManagerUSDC));
-        loanManager.remove();
-        wmBalAfter = usdcPool.balanceOf(address(withdrawalManagerUSDC));
-        assertEq(usdcPool.balanceOf(address(loanManager)), lmUSDC / 10 ** 12);
-        assertEq(wmBalBefore - wmBalAfter, redeemAmount / 10 ** 12);
-        assertEq(loanManager.escrowedMapleShares(), 0);
-        assertEq(loanManager.awaitingRedemption(), false);
-
-        //Requesting redemption again
-        wmBalBefore = usdcPool.balanceOf(address(withdrawalManagerUSDC));
-        loanManager.requestRedeem(redeemAmount);
-        wmBalAfter = usdcPool.balanceOf(address(withdrawalManagerUSDC));
-        assertEq(usdcPool.balanceOf(address(loanManager)), (lmUSDC - redeemAmount) / 1e12);
-        assertEq(wmBalAfter - wmBalBefore, redeemAmount / 10 ** 12);
+    function test_redeem_USDC_withoutRequest_revert() external {
+        uint256 amount = 1e7 * 1e6;
+        _investAssets(USDC, amount);
 
-        _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (uint256 exitWindowStart,) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
+        // time warp
+        vm.warp(block.timestamp + 2 weeks);
 
-        vm.warp(exitWindowStart);
+        vm.startPrank(NSTBL_HUB);
 
-        //Redeeming requested assets
+        vm.expectRevert("LM: No redemption requested");
         loanManager.redeem();
 
-        assertEq(lusdc.balanceOf(NSTBL_HUB), lmUSDC - (redeemAmount - loanManager.escrowedMapleShares() * 10 ** 12));
-        assertEq(lusdc.totalSupply(), lmUSDC - (redeemAmount - loanManager.escrowedMapleShares() * 10 ** 12));
-
-        if (loanManager.escrowedMapleShares() == 0) {
-            assertFalse(loanManager.awaitingRedemption());
-        } else {
-            assertTrue(loanManager.awaitingRedemption());
-        }
         vm.stopPrank();
     }
 
-    function test_redeem_USDC_withoutRequest_revert() external {
+    function test_remove_USDC_withoutRequest_revert() external {
         uint256 amount = 1e7 * 1e6;
         _investAssets(USDC, amount);
 
@@ -476,8 +398,8 @@ contract TestRedeem is BaseTest {
 
         vm.startPrank(NSTBL_HUB);
 
-        vm.expectRevert("LM: No redemption requested");
-        loanManager.redeem();
+        vm.expectRevert("LM: No Tokens to remove");
+        loanManager.remove();
 
         vm.stopPrank();
     }
@@ -560,21 +482,23 @@ contract TestGetter is BaseTest {
     }
 
     function test_previewRedeem_USDC() external {
-        uint256 amount = 1e7 * 1e6;
+        uint256 amount = 1e5 * 1e6;
         _investAssets(USDC, amount);
 
         uint256 lmUSDC = lusdc.balanceOf(NSTBL_HUB);
         vm.startPrank(NSTBL_HUB);
         loanManager.requestRedeem(lmUSDC);
         vm.stopPrank();
-
+        vm.warp(block.timestamp + 100 days);
         assertEq(loanManager.previewRedeem(lmUSDC), 0);
-        uint256 _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
-        uint256 _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
-        assertEq(_exitCycleId, _currCycleId + 2);
-        (uint256 exitWindowStart,) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
-
-        vm.warp(exitWindowStart);
+        // uint256 _currCycleId = withdrawalManagerUSDC.getCurrentCycleId();
+        // uint256 _exitCycleId = withdrawalManagerUSDC.exitCycleId(address(loanManager));
+        // assertEq(_exitCycleId, _currCycleId + 2);
+        // (uint256 exitWindowStart,) = withdrawalManagerUSDC.getWindowAtId(_exitCycleId);
+
+        // vm.warp(exitWindowStart);
+        vm.prank(poolDelegateUSDC);
+        withdrawalManagerUSDC.processRedemptions(lmUSDC / 10 ** 12);
         console.log("Assets available for Redemption: ", loanManager.previewRedeem(lmUSDC));
     }
 
